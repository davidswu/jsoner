package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

var (
	typ       = flag.String("type", "", "Type name; must be set ")
	buildTags = flag.String("tags", "", "comma-separated list of build tags to apply")
)

func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\tjsoner -type MyCoolStruct\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("jsoner: ")
	flag.Usage = Usage
	flag.Parse()

	var tags []string
	if len(*buildTags) > 0 {
		tags = strings.Split(*buildTags, ",")
	}

	if len(*typ) == 0 {
		log.Fatal(flag.Usage)
	}

	cfg := &packages.Config{
		Mode:       packages.LoadSyntax,
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
	}
	pkgs, err := packages.Load(cfg, ".")
	if err != nil {
		log.Fatal(err)
	}

	if len(pkgs) != 1 {
		log.Fatal("unable to find package")
	}

	g := &Generator{
		PkgName: pkgs[0].Name,
		Type:    *typ,
	}

	outputName := fmt.Sprintf("%s_jsoner.go", strings.ToLower(*typ))
	f, err := os.Create(outputName)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	t := template.Must(template.New(g.PkgName).Parse(tpl))
	if err := t.Execute(f, g); err != nil {
		log.Fatal(err)
	}

}

type Generator struct {
	PkgName string
	Type    string
}

var tpl = `// Code generated by 'jsoner {{.Type}}'. DO NOT EDIT.

package {{.PkgName}}

import (
	"fmt"
	"encoding/json"
)

// MarshalJSON implements the json.Marshaler interface for {{.Type}}
func (i {{.Type}}) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}
// UnmarshalJSON implements the json.Unmarshaler interface for {{.Type}}
func (i *{{.Type}}) UnmarshalJSON(data []byte) error {
	var s {{.Type}}
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*i = s
	return nil
}
`
